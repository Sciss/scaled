//
// Scaled - a scalable editor extensible via JVM languages
// http://github.com/samskivert/scaled/blob/master/LICENSE

package scaled.project

import scaled._
import scaled.major.EditingMode

/** Provides configuration for [[ProjectMode]]. */
object ProjectConfig extends Config.Defs {

  // TODO
}

/** A minor mode which provides fns for interacting with project files and services.
  *
  * Some stock key bindings are also redirected toward project-centric versions, for example
  * `C-x C-f` is rerouted to `find-file-in-project`. Where possible, the original fns are exposed
  * via slightly varied key bindings.
  *
  * Any major mode that includes the `project` tag will trigger the activation of this minor mode.
  */
@Minor(name="project",
       tags=Array("project"),
       desc="""A minor mode that provides project-centric fns.""")
class ProjectMode (env :Env, psvc :ProjectService, major :EditingMode) extends MinorMode(env) {

  // TODO: it's possible that our buffer's file could change and become part of a new project;
  // do we really want to handle that crazy case?
  val project :Project = psvc.projectFor(buffer.file).reference(buffer)

  override def configDefs = ProjectConfig :: super.configDefs
  override def keymap = Seq(
    "C-x C-f" -> "find-file-in-project",
    // TODO: this doens't work, we need to wire up major:find-file to route to major mode fn
    // "S-C-x S-C-f" -> "find-file"
    "S-C-x S-C-f" -> "find-file-default",

    "C-c S-C-c" -> "project-recompile"
  )

  override def dispose () {
    super.dispose()
    project.release(buffer)
  }

  // listen for compilation notes and highlight any that are in our buffer
  note(project.compileNotes onChange { (notes, onotes) =>
    clearNotes(onotes)
    highlightNotes(notes)
  })
  highlightNotes(project.compileNotes())

  /** Highlights the regions identified in the supplied compiler notes. */
  def highlightNotes (ns :Seq[Compiler.Note]) :Unit = onNotes(ns) { (note, start, end) =>
    buffer.addStyle(note.styleClass, start, end)
  }
  /** Clears the regions identified in the supplied compiler notes. */
  def clearNotes (ns :Seq[Compiler.Note]) :Unit = onNotes(ns) { (note, start, end) =>
    buffer.removeStyle(note.styleClass, start, end)
  }
  private def onNotes (ns :Seq[Compiler.Note])(fn :(Compiler.Note,Loc,Loc) => Unit) {
    ns.filter(_.file == buffer.file) foreach { note =>
      val start = buffer.loc(note.offset) ; val end = buffer.forward(start, note.length)
      fn(note, start, end)
    }
  }

  //
  // FNs

  @Fn("Reads a project file name from the minibuffer (with smart completion), and visits it.")
  def findFileInProject () {
    editor.miniRead(
      s"Find file in project (${project.name}):", "", project.fileHistory, project.fileCompleter
    ) onSuccess editor.visitFile
  }

  @Fn("TEMP: forwards find-file to major mode")
  def findFileDefault () :Unit = major.findFile()

  @Fn("""Initiates a compilation of the current project. Notes generated by the compilation will
         be displayed in the appropriate buffers when they are available.""")
  def projectRecompile () {
    project.recompile.onSuccess(editor.emitStatus).onFailure(editor.emitError)
  }
}
