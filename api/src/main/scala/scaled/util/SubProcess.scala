//
// Scaled - a scalable editor extensible via JVM languages
// http://github.com/scaled/scaled/blob/master/LICENSE

package scaled.util

import java.io.{BufferedReader, InputStreamReader, OutputStreamWriter, PrintWriter}
import java.nio.file.{Path, Paths}
import java.util.concurrent.{Executor => JExecutor}
import scaled._

/** Factory methods &c for [[SubProcess]. */
object SubProcess {

  /** Configures a to-be-created subprocess. */
  case class Config (
    /** The command and arguments to be executed. */
    cmd :Array[String],
    /** The environment in which to invoke the command. Defaults to empty. */
    env :Map[String,String] = Map(),
    /** The current working directory for the process. Defaults to Scaled's cwd. */
    cwd :Path = Paths.get(System.getProperty("user.dir"))
  )

  /** An event generated by a sub-process. */
  sealed trait Event
  /** An event generated when a line of output is received from the sub-process.
    * @param isErr true if the output came from stderr, false if it came from stdout. */
  case class Output (text :String, isErr :Boolean) extends Event
  /** An event generated if the sub-process fails to start, or if an error occurrs reading from
    * stdout or stderr. */
  case class Failure (cause :Throwable, isErr :Boolean) extends Event
  /** An event generated when EOF is reached on a sub-process input stream.
    * @param isErr whether EOF came on stderr (true) or stdout (false). */
  case class Complete (isErr :Boolean) extends Event

  /** Starts a subprocess with the specified configuration. Output will be directed to `buffer`. If
    * the subprocess fails to start, the starting exception will be captured, recorded to `buffer`
    * and then rethrown. */
  def apply (config :Config, exec :Executor, buffer :Buffer) :SubProcess = {
    val events = Signal[Event](exec.uiExec)
    events.onValue { _ match {
      case Output(text, _)   => buffer.append(Line.fromTextNL(text))
      case Failure(cause, _) => buffer.append(Line.fromTextNL(Errors.stackTraceToString(cause)))
      case Complete(_)       => // nada
    }}
    new SubProcess(config, events)
  }
}

/** Encapsulates a sub-process.
  * @param config the launch configuration for the sub-process.
  * @param events a signal to which events from this sub-process will be emitted. Note that events
  * are emitted from background worker threads, so this signal should generally be created with the
  * UI executor. Note also that events may be emitted *during* the construction of this SubProcess,
  * so any listeners should already be in place before the signal is passed into this constructor.
  */
class SubProcess (config :SubProcess.Config, events :Signal[SubProcess.Event])
    extends AutoCloseable {
  import SubProcess._

  /** Sends `line` to the subprocess's stdin. A newline is automatically appended. */
  def send (line :String) {
    out.println(line)
    out.flush()
  }

  /** Sends `lines` to the subprocess's stdin. Newlines are automatically appended. */
  def send (lines :Seq[String]) {
    lines foreach out.println
    out.flush()
  }

  /** Closes this subprocess's output stream. This may trigger termination if it expects that sort
    * of thing. This must only be called after [[start]]. */
  def close () {
    process.getOutputStream.close()
  }

  /** Terminates the subprocess forcibly. */
  def kill () {
    process.destroyForcibly()
  }

  /** Waits for the process to complete and returns its exit code. */
  def waitFor () :Int = {
    process.waitFor()
  }

  override def toString = s"SubProcess(${config.cmd.mkString(" ")})"

  private def read (reader :BufferedReader, isErr :Boolean) :Unit = try {
    while (true) {
      val line = reader.readLine
      if (line == null) {
        events.emit(Complete(isErr))
        return
      }
      events.emit(Output(line, isErr))
    }
  } catch {
    case e :Exception => events.emit(Failure(e, isErr))
  }

  private lazy val process = {
    val pb = new ProcessBuilder(config.cmd :_*)
    pb.directory(config.cwd.toFile)
    config.env foreach { (k, v) => pb.environment.put(k, v) }
    pb.start
  }

  protected lazy val out = new PrintWriter(new OutputStreamWriter(process.getOutputStream, "UTF-8"))

  // kick things off immediately; if the process fails to start, an exception will be thrown before
  // these threads are started; otherwise they'll run until the process's streams are closed
  try {
    val in  = new BufferedReader(new InputStreamReader(process.getInputStream, "UTF-8"))
    val err = new BufferedReader(new InputStreamReader(process.getErrorStream, "UTF-8"))
    new Thread("Subproc: stdin") {
      setDaemon(true)
      override def run () = read(in, false)
    }.start()
    new Thread("Subproc: stderr") {
      setDaemon(true)
      override def run () = read(err, true)
    }.start()
  } catch {
    case err :Throwable => events.emit(Failure(err, true))
  }
}
